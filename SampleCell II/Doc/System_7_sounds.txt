The original documentation seems to be this (pages 1138 and later):
	https://vintageapple.org/inside_o/pdf/Inside_Macintosh_Volume_VI_1991.pdf

These files use an empty data fork, with all their data residing in the resource
fork instead. The file type is internally identified as "sfil" (all lowercase),
which is not to be confused with SoundDesigner I files which are identified as
"SFIL" (all uppercase).

They use 2 types of resources:
	Type: "alis"
		ID: 1, Name: None (name offset of 0xFFFF)
			Unsure. Doesn't seem particularly relevant.

	Type: "snd "
		ID: Variable (0 - 8191 reserved)
		Name: Variable (usually same as filename)
			The actual sound data, with a small header.


The "snd " resource is what we care about and is what's documented below.

There's two types of "snd " resource. The only significative difference between
both types appears to be that Type 2 stores a reference count instead of Type
1's synth count, and does not store the "first synth ID" and 32-bit
initialization bitfield. Both can contain both commands and audio, but Type 2 is
expected to always contain a single "buffer" command. Type 2 was considered
deprecated as far back as 1991, and was intended for sampled audio only (even
though it also has provisions for commands).

Type 1 sampled audio relies on a single synth type of 5 (which I assume is
dedicated to sample-based synthesis). It then sends a 32-bit bitfield to
initialize it. The bitfield's values are described in Inside Macintosh Volume
VI, page 1158. Finally, just like type 2, it contains a single command with
opcode 0x8051, param1 of 0 and param2 variable (but usually 0x14 on type 1).
0x8051 is a "buffer" opcode, param2 is the address (relative to the "snd "
resource's data) of the audio's metadata.

The documentation claims (Inside Macintosh Volume VI, page 1163) that you can
use "[...] multiple buffers and then issue successive bufferCmd commands [...]",
"each buffer must contain a sampled sound header". Also, "the sound will play
smoothly, without audible gaps". I guess that means you could have several
buffer commands in a snd resource, but they're not individual samples (they
should be spliced together).


The type is determined by a uint16 at the very start of the resource. After that
the header follows.


Header (type 1)
	0x00: uint16. Synth count.
	0x02: uint16. Called "First synth ID" by the documentation.
	0x04: uint32, bitfield. Synth init flags.
	0x08: uint16. Command count.

	Synth count may be 0; in which case, commands immediately follow (starting
	at 0x02).

	First synth ID seems to just be the general synth ID. As far as I know, only
	resources containing samples using compression ever contain another synth
	ID.

	I think what's actually going on with type 1 files is, after the synth
	count, it's an array of synth ID + init bitfield that's supposed to follow.
	I'm not sure if each synth ID + init would be immediately followed by
	another one, or if each synth's commands are supposed to be interleaved. See
	Inside Macintosh Volume VI, page 1140.

Synth ID
	square = 1,
	wavetable = 3,
	sample = 5,
	three_to_one = 11,
	six_to_one = 13

Synth init values
	left_ch = 2,
	right_ch,
	ch0,
	ch1,
	ch2, //may also mean no lerp
	ch3, //may also mean no drop-sample
	mono = 0x80,
	stereo = 0xC0,
	MACE3 = 0x300,
	MACE6 = 0x400

Header (type 2)
	0x00: uint16. Reference count. Not sure what this does.
	0x02: uint16. Command count.


Commands immediately follow the header.

Command
	0x00: uint16. Opcode.
	0x02: uint16. Param 1.
	0x04: uint32. Param 2.

	Opcodes are listed in Inside Macintosh Volume VI, page 1223. It appears only
	the LSB is used, with the 0x8000 part really just a flag to indicate param 2
	is an offset to the command's data.


There's three variants of the audio header. For all variants:
	Absence of looping is flagged by both loop start and loop end being 0.

	The pointers in the extended and compressed headers may be null. In fact,
	markers are not used and their pointer should be set to 0.

	Reserved variables should also be set to 0.

Audio header (standard)
	0x00: uint32. Audio pointer. Audio in file only if null.
	0x04: uint32. Audio size in bytes.
	0x08: 16.16 fixed-point (4 bytes). Sample rate. Integer part unsigned.
	0x0C: uint32. Loop start.
	0x10: uint32. Loop end.
	0x14: uint8 (enum). Header type.
	0x15: uint8. Root note. MIDI.

	Judging from table 22-7 in Inside Macintosh Volume VI, page 1219; it looks
	like samples using the standard audio header are always 8-bit.

Audio header (extended)
	0x00: uint32. Audio pointer. Audio in file only if null.
	0x04: uint32. Channel count.
	0x08: 16.16 fixed-point (4 bytes). Sample rate. Integer part unsigned.
	0x0C: uint32. Loop start.
	0x10: uint32. Loop end.
	0x14: uint8 (enum). Header type.
	0x15: uint8. Root note. MIDI.
	0x16: uint32. Frame count.
	0x1A: 80-bit IEEE float. AIFF sample rate.
	0x24: uint32. Mark chunk pointer. Should be null.
	0x28: uint32. Inst chunk pointer. May be null.
	0x2C: uint32. AES chunk pointer. May be null.
	0x30: uint16. Sample size in bits.
	0x32: uint16. Reserved.
	0x34: uint32[3]. Reserved.

	Stereo samples use the extended header.

Audio header (compression)
	0x00: uint32. Audio pointer. Audio in file only if null.
	0x04: uint32. Channel count.
	0x08: 16.16 fixed-point (4 bytes). Sample rate. Integer part unsigned.
	0x0C: uint32. Loop start.
	0x10: uint32. Loop end.
	0x14: uint8 (enum). Header type.
	0x15: uint8. Root note. MIDI.
	0x16: uint32. Frame count.
	0x1A: 80-bit IEEE float. AIFF sample rate.
	0x24: uint32. Mark chunk pointer. Should be null.
	0x28: uint32[2]. Reserved.
	0x30: uint32. State pointer. State for decoder?
	0x34: uint32. Leftover pointer. I'm not really sure what this does.
	0x38: uint16 (enum). Compression ID.
	0x3A: uint16. Packet size in bits. 8 for 6:1, 16 for 3:1.
	0x3C: uint16. Compression synth ID. Should be 0 if no compression.
	0x3E: uint16. Uncompressed sample size in bits.

	Storing both compression ID and compression synth ID seems redundant.

	Documentation for the compressed header claims samples should be in "offset
	binary format", as opposed to two's complement. I have no idea what "offset
	binary format" means. Is it just unsigned? The same paragraph claims only
	8-bit samples are supported. This probably only applies to compressed
	samples, since the files I have (which use the extended header) use 16-bit
	samples. Similarly, the "offset binary format" thing might just be a weird
	way of saying 8-bit audio is unsigned PCM.


Header type enum
	std,
	cmp = 0xFE,
	ext = 0xFF


Compression ID enum
	none,
	three_to_one = 3, //MACE3?
	six_to_one //MACE6?
