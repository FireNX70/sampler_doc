FILP
	0x00: char array[4]. FourCC. Standard IFF data.
	0x04: uint32. Size. Standard IFF data.
	0x08: uint32. Entry count.
	0x0C: uint32. Entry size.
	0x10: Entries.

	Expected entry size for Mac is 68 (0x44). Expected entry size for Windows is
	331 (0x14B).


FILP entry
	0x00: uint8. Volume name length.
	0x01: char array[31]. Volume name. Always 31 bytes in size.
	0x20: uint8. Filename length.
	0x21: char array[31]. Filename. Always 31 bytes in size.
	0x40: char array[4]. File type. FourCC for the referenced file.

	Windows only
	0x44: uint16. Some sort of count? Seems to always be 1.
	0x46: C string. File path. Padded to the end of the entry (after the NUL).

	Volume name and filename are always 31 bytes in size. Their respective
	lengths are their used lengths. Unused space contains junk.
	The volume name may be empty, at least on Windows. A volume name length of 0
	is perfectly legal.

	Paths are null-terminated strings. These look like they're preceded by some
	sort of count. It might also look like they're followed by the current
	file's name, if the path's short enough, but it's actually just junk data
	(it just so happens to be the current file's name).
	Paths use '\' as delimiter. Makes sense, since these are only stored on the
	Windows version of FILP.
	Referencing something in the same filesystem (an instrument in filesystem C:
	from a bank also in filesystem C:) will have its path stored as a relative
	path.
	Referencing something in another filesystem will have its path stored as
	an absolute path (something like "D:\path\to\file").
	The path seems to always have 261 bytes allocated to it.

	The lack of a path in the Mac version makes me think it relies on a standard
	directory structure.
